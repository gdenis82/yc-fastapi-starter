### Настройка GitLab CI/CD для FastAPI Project (Гибридный подход)

В этом проекте используется гибридный подход: 
1. **Инфраструктура** (сети, Kubernetes, база данных, реестр) управляется вручную с локального компьютера через Terraform/`deploy.ps1`.
2. **Деплой приложения** (сборка образа, миграции БД, обновление в K8s) выполняется автоматически через GitLab CI/CD при каждом пуше.

Это самый стабильный и быстрый вариант, так как создание инфраструктуры занимает 20 минут, а деплой приложения — всего 2-3 минуты.

---

### Пошаговая инструкция

#### Шаг 1: Развертывание инфраструктуры
Если вы еще не развернули инфраструктуру, сделайте это локально:
1. Убедитесь, что `terraform/terraform.tfvars` заполнен.
2. Запустите скрипт:
   ```powershell
   ./deploy.ps1
   ```
   Дождитесь успешного завершения. Все ресурсы (K8s, DB, Registry) будут созданы.

#### Шаг 2: Получение ID ресурсов
После завершения работы скрипта, получите необходимые идентификаторы из Terraform:
```powershell
cd terraform
terraform output
```

#### Шаг 3: Настройка переменных в GitLab
Перейдите в ваш проект в GitLab: **Settings -> CI/CD -> Variables** и добавьте следующие переменные:

| Переменная | Описание / Где взять |
| :--- | :--- |
| `YC_SA_KEY` | Содержимое JSON ключа сервисного аккаунта (Тип: **File**) |
| `YC_CLOUD_ID` | Ваш ID облака |
| `YC_FOLDER_ID` | Ваш ID каталога |
| `REGISTRY_ID` | Значение `registry_id` из вывода `terraform output` |
| `K8S_CLUSTER_ID` | Значение `k8s_cluster_id` из вывода `terraform output` |
| `LOCKBOX_ID` | Значение `lockbox_secret_id` из вывода `terraform output` |
| `EXTERNAL_IP` | Значение `external_ip` из вывода `terraform output` |
| `DOMAIN_NAME` | Ваш домен (например, `tryout.site`) |

> **Важно по правам доступа**: Убедитесь, что ваш Сервисный Аккаунт (ключ которого в `YC_SA_KEY`) имеет следующие роли:
> - `container-registry.images.pusher` (для загрузки образов в реестр)
> - `lockbox.payloadViewer` (для чтения секретов)
> - `k8s.clusters.agent` или `admin` (для управления кластером)
>
> **Важно по YC_SA_KEY**: При добавлении в GitLab:
> 1. Выберите тип **File**.
> 2. **НЕ включайте** опцию "Mask variable". GitLab не позволяет маскировать значения с пробелами или переносами строк (что обычно есть в JSON).
> 3. Использование типа **File** само по себе безопасно, так как содержимое файла не выводится в логи пайплайна, если вы не делаете этого явно (например, через `cat`).
> 
> Если вы все же хотите использовать тип **Variable**, вам придется удалить все пробелы и переносы строк из JSON ключа вручную перед вставкой, но это не рекомендуется.

---

### Как это работает (Mono-repo CI/CD)

В проекте реализована структура **Multi-project / Child Pipelines**, что оптимизирует запуск задач:

1. **Корневой `.gitlab-ci.yml`**:
   - Служит диспетчером. Он не выполняет сборку сам, а запускает "дочерние" пайплайны для конкретных сервисов.
   - **Оптимизация триггеров**: Пайплайн запускается только при изменениях в папке конкретного сервиса (например, `services/backend/`).
   - **Игнорирование мета-файлов**: Изменения в `.md`, `.gitignore` и лицензиях игнорируются глобально через `workflow:rules`, чтобы не тратить ресурсы CI на обновление документации.

2. **Пайплайны сервисов (например, `services/backend/.gitlab-ci.yml`)**:
   - Содержат изолированную логику: тесты, сборку Docker-образа и деплой в K8s.
   - Используют контекст своей директории, что упрощает команды сборки.

3. **Автоматизация**: При каждом коммите в `main`:
   - GitLab проверяет, какие файлы изменились.
   - Если изменился код в `services/backend`, запускается соответствующий дочерний пайплайн.
   - Дочерний пайплайн прогоняет тесты, собирает образ, применяет миграции и обновляет Helm-релиз.

### Почему это удобно?
* **Изоляция**: Ошибки в одном сервисе не блокируют разработку других.
* **Скорость**: Запускаются только те части пайплайна, которые реально изменились.
* **Масштабируемость**: Легко добавить новый сервис, просто создав для него `.gitlab-ci.yml` и добавив триггер в корень.
* **Экономия ресурсов**: Нет лишних запусков при правке документации или настроек Git.
